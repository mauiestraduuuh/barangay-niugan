generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

enum Role {
  ADMIN
  STAFF
  RESIDENT
}

enum CertificateStatus {
  PENDING
  APPROVED
  REJECTED
}

enum FeedbackStatus {
  PENDING
  RESOLVED
  IN_PROGRESS
}

enum RegistrationStatus {
  PENDING
  APPROVED
  REJECTED
}

//
// USERS
//
model User {
  user_id    Int      @id @default(autoincrement())
  username   String   @unique
  password   String
  role       Role     @default(RESIDENT)
  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  // Relations
  residents            Resident[]
  certificateApprovals CertificateRequest[]  @relation("ApprovedBy")
  digitalIdIssued      DigitalID[]           @relation("IssuedBy")
  demographicAssigned  DemographicTag[]      @relation("AssignedBy")
  announcementsPosted  Announcement[]
  feedbackResponded    Feedback[]            @relation("RespondedBy")
  clearancesIssued     Clearance[]           @relation("ClearanceIssuedBy")
  eventsCreated        Event[]               @relation("EventCreatedBy")
  approvedRequests     RegistrationRequest[] @relation("ApprovedRequests")
}

//
// RESIDENTS
//
model Resident {
  resident_id  Int      @id @default(autoincrement())
  user_id      Int
  first_name   String
  last_name    String
  birthdate    DateTime
  gender       String?
  address      String?
  contact_no   String?
  senior_mode  Boolean  @default(false)
  household_id Int?
  created_at   DateTime @default(now())
  updated_at   DateTime @updatedAt

  // Relations
  user                User                 @relation(fields: [user_id], references: [user_id], onDelete: Cascade)
  household           Household?           @relation("HouseholdMembers", fields: [household_id], references: [id], onDelete: SetNull)
  certificateRequests CertificateRequest[]
  digitalIds          DigitalID[]
  demographicTags     DemographicTag[]
  feedbacks           Feedback[]
  clearances          Clearance[]
  headedHouseholds    Household[]          @relation("HouseholdHead")
}

//
// HOUSEHOLDS
//
model Household {
  id         Int      @id @default(autoincrement())
  head_id    Int
  address    String
  created_at DateTime @default(now())

  // Relations
  head    Resident   @relation("HouseholdHead", fields: [head_id], references: [resident_id], onDelete: Cascade)
  members Resident[] @relation("HouseholdMembers")

  @@index([head_id])
}

//
// CERTIFICATE REQUESTS
//
model CertificateRequest {
  request_id       Int               @id @default(autoincrement())
  resident_id      Int
  certificate_type String
  purpose          String?
  status           CertificateStatus @default(PENDING)
  approved_by      Int?
  requested_at     DateTime          @default(now())
  approved_at      DateTime?
  file_path        String?

  // Relations
  resident   Resident @relation(fields: [resident_id], references: [resident_id], onDelete: Cascade)
  approvedBy User?    @relation("ApprovedBy", fields: [approved_by], references: [user_id])
}

//
// DIGITAL IDs
//
model DigitalID {
  digital_id  Int      @id @default(autoincrement())
  resident_id Int      @unique
  id_number   String   @unique
  qr_code     String?
  issued_by   Int
  issued_at   DateTime @default(now())

  // Relations
  resident Resident       @relation(fields: [resident_id], references: [resident_id], onDelete: Cascade)
  issuedBy User           @relation("IssuedBy", fields: [issued_by], references: [user_id])
  tags     DigitalIDTag[]
}

model DigitalIDTag {
  id        Int    @id @default(autoincrement())
  digitalId Int
  tag       String

  digitalID DigitalID @relation(fields: [digitalId], references: [digital_id])
}

//
// DEMOGRAPHIC TAGS
//
model DemographicTag {
  tag_id      Int      @id @default(autoincrement())
  resident_id Int
  tag_type    String
  assigned_by Int
  assigned_at DateTime @default(now())

  // Relations
  resident   Resident @relation(fields: [resident_id], references: [resident_id], onDelete: Cascade)
  assignedBy User     @relation("AssignedBy", fields: [assigned_by], references: [user_id])
}

//
// ANNOUNCEMENTS
//
model Announcement {
  announcement_id Int      @id @default(autoincrement())
  title           String
  content         String?
  posted_by       Int
  posted_at       DateTime @default(now())
  is_public       Boolean  @default(true)

  // Relations
  postedBy User @relation(fields: [posted_by], references: [user_id])
}

//
// FEEDBACK
//
model Feedback {
  feedback_id  Int            @id @default(autoincrement())
  resident_id  Int
  message      String
  status       FeedbackStatus @default(PENDING)
  response     String?
  responded_by Int?
  submitted_at DateTime       @default(now())
  responded_at DateTime?

  // Relations
  resident    Resident @relation(fields: [resident_id], references: [resident_id], onDelete: Cascade)
  respondedBy User?    @relation("RespondedBy", fields: [responded_by], references: [user_id])
}

//
// CLEARANCES
//
model Clearance {
  clearance_id Int               @id @default(autoincrement())
  resident_id  Int
  issued_for   String
  purpose      String?
  status       CertificateStatus @default(PENDING)
  issued_by    Int?
  requested_at DateTime          @default(now())
  issued_at    DateTime?
  file_path    String?

  // Relations
  resident Resident @relation(fields: [resident_id], references: [resident_id], onDelete: Cascade)
  issuer   User?    @relation("ClearanceIssuedBy", fields: [issued_by], references: [user_id])
}

//
// EVENTS
//
model Event {
  id          Int      @id @default(autoincrement())
  title       String
  description String?
  location    String?
  event_date  DateTime
  created_by  Int?
  created_at  DateTime @default(now())
  is_public   Boolean  @default(true)

  // Relations
  creator User? @relation("EventCreatedBy", fields: [created_by], references: [user_id])
}

model RegistrationRequest {
  request_id   Int               @id @default(autoincrement())
  first_name   String
  last_name    String
  email        String            @unique
  contact_no   String?
  birthdate    DateTime
  role         Role
  status       RegistrationStatus @default(PENDING)
  submitted_at DateTime           @default(now())
  approved_by  Int?

  approvedBy User? @relation("ApprovedRequests", fields: [approved_by], references: [user_id])
}


